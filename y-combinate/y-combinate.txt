Y-комбинатор позволяет в анонимной функции использовать рекурсию с использованием самой себя, без необходимости назначения ей имени — функция остаётся анонимной.

Скажем, у нас есть неанонимная рекурсивная функция вычисления факториала:
def fact(n):
    return n * fact(n-1) if n > 0 else 1
print fact(10)

Это работает, т.к. у нашей функции есть имя fact и мы можем по нему функцию вызывать внутри неё самой.

Но если мы захотим написать анонимную функцию вычисления факториала, мы столкнемся с проблемой — как нам внутри функции вызвать её саму, не имея имени.
Можно попробовать сделать так:
fact = lambda self, n: n * self(self, n) if n > 0 else 1
print fact(fact, 10)

В данном случае имя функции не встречается внутри неё. Но при внешнем вызове функции приходится передавать в качестве одного из аргументов ссылку на неё саму. Это можно обернуть так:
wrap = lambda fn, *args: fn(fn, *args)
fact = lambda self, n: n * self(self, n) if n > 0 else 1
print wrap(fact, 10)

Теперь мы её ещё немного дообернем:
y = lambda fn: lambda *args: fn(fn, *args)
fact = y(lambda self, n: n * self(self, n) if n > 0 else 1)

Вот y и есть Y-комбинатор, к тому же анонимный. Пользуем inline как то так:
# применяем анонимную рекурсивную функцию
map(
    (lambda fn: lambda *args: fn(fn, *args))(
        lambda self, n: n * self(self, n-1) if n > 0 else 1),
    [1,2,3]
)
